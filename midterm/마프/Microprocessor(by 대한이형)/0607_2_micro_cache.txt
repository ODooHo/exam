사상 방식
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=h22chance&logNo=221159437479


캐시 히트: CPU가 원하는 데이터가 캐시에 있는 상태
캐시 미스: CPU가 원하는 데이터가 캐시에 없는 상태, 이 경우 주기억 장치로부터 데이터를 읽어온다.

·히트률 (hit ratio): 캐시에 히트되는 정도(H)
H = 캐시에 히트되는 횟수 / 전체 기억장치 액세스 횟수

·미스율 (miss ratio): (1-H)

	예제 6-5
> Tc = 5
> Tm = 50
> Ta = 5 * (x*0.01) + (5 + 50) * (1 - x*0.01)
 -> 확률이므로 0.01 곱하기 (책에는 5를 안더함)

> plot(x, Ta, xlab='Hit Ratio', ylab='Average Ta')



 *참조 지역성(locality of reference)
·공간적 지역성(spatial locality): 인접하여 저장되어 있는 데이터들이 연속적으로 액세스될 가능성 높다.

·시간적 지역성(temporal locality): 예를 들어 for루프 5천만번.. 한번 쓴 함수는 또 쓸 확률이 높다.
공통변수 (ex: 전역변수, 자주쓰는 변수는 계속 access됨)

11p.
	2. 사상 방식
318p. 
·블록, 워드, 라인 개념

블록을 한줄로 싹 눕혀서 만들어 놓는다. 그리고 캐시를 한줄 씩 읽는다.
-> 메모리에 있는 한 블록이 캐시에 있는 한 줄이 된다

·주기억 장치의 용량 = 2^n 워드, 블록 = K개 워드
-> 전체 블록의 수 = 2^n / K 개

·라인: 캐시의 라인 번호는 m개 존재. 0 - m-1까지
각 라인에는 '워드가 K'개 (ex: 워드가 32bit면. 32K개)


	* 사상 방식을 설명하기 위한 모델 예
·주기억 장치의 용량: 128(2^7)바이트. 따라서 주소 지정에 7비트 필요. 바이트 단위로 지정되며, 워드 길이는 1바이트
·캐시 용량 32바이트. 따라서 주소 지정에 5비트 필요
·블록 크기는 4바이트(4워드)이므로, 주기억 장치에 128/4 = 32개의 블록 존재.
·블록 크기가 4바이트 이므로 캐시 라인의 크기도 4바이트. 결과적으로 캐시 라인의 수는 32/4 = 8개.
·주기억 장치 블록 32개를 캐시 라인 8개에 배치해야 하므로. 블록 번호 5비트를 캐시 라인 3비트로 매핑해야함.


	# 직접 사상
	[태그 2] [라인 3] [워드 2]
캐시 라인 번호 연산 
 -> i = j mod m  (나머지 연산)

324p. 예제 6-6
	***동작 예시
1. 라인 필드가 101이므로 5번 캐시 라인 선택
2. 선택된 5번 라인의 태그 비트 11을 읽어서 주기억 장치 태그 필드인 11과 비교
3. 두 태그 가 일치하므로 캐시 히트
4. 워드 필드가 01 이므로 poet 중 o 인출
5. 만약 히트가 안됐을 경우, 주기억 장치로 가서. 값 하나만 가져오는 것이 아니라, 해당 블록을 가져와서 위치에 있는 값과 바꿔치기치기한다.

	
	# 완전-연관 사상
	[태그 5] [워드 2]

	*** 동작 예시
1. 캐시로 주기억 장치 주소 11001 11 이 보내짐 .
2. 2번 캐시 라인의 11001과 일치하므로 히트
3. 워드필드가 11이므로 navy중 y인출
4. 미스일 경우 주기억장치로 가서 가져온다. 인출된 블록은 5번 캐시 라인 (비어있는 라인)에 저장됨

	# 세트-연관 사상
	[태그 3 ] [세트 2] [워드 2]
캐시 라인 m은 v개의 세트들로 나뉘며, 각 세트들은 k개의 라인들로 구성 (k-way)
·m = v * k
·i = j mod v

캐시 라인이 8이고, 세트 당 캐시 라인수가 2개라면 
세트 수는 8/2 = 4이다. 따라서 j mod 4로 계산해야함.
예시: 10번 블록은 10%4= 2번 블록

	*** 동작 예시
1. 001 00 10 이 캐시로 보내짐. 태그 001, 세트 00, 워드 10
2. 00 세트 번호를 이용해 캐시의 0번 세트 확인
3. 0번 세트 라인에 태그 001과 일치하는 것 확인
4. 히트다 히트
5. 워드가 10 이므로 gift 중에서 f 인출
6. 미스라면, 적절한 "교체 알고리즘"으로 2개 중 하나 교체

-------------------------------------------
'세트-연관 사상에서'	캐시에 넣어야하는데 자리가 없다?

	3. 교체 알고리즘
·LRU: 가장 오래전에 사용된 것
·FIFO: 적재된 지 가장 오래된 것
·LFU: 참조 횟수가 가장 적은 것
·RANDOM: 랜덤 ㅋ


-----------------------------------------

·Write-through
: 모든 쓰기 동작이 캐시와 주기억 장치에 동시에 수행됨. 
 
·Write-back
주기억 장치는 느리니까 일단 캐시에 쓰고 다시 돌아오자. = 캐시에서 데이터가 변경되어도 주기억 장치에는 갱신되지 않는 방식 (빚 지는 것)

	각 방식의 장단점
 ·Write-through
장점: 안전하다
단점: 느리다

 ·Write-back
장점: 쓰기 동작의 횟수가 최소화되고, 시간이 짧음
단점: 캐시의 내용과 주기억 장치의 내용이 서로 다르다 -> '블록을 교체할 때 문제가 된다.'
=> 블록을 교체할 때 캐시의 상태를 확인하여 주기억 장치에 갱신하는 동작이 선행되어야 하며, 이를 위해 '상태 비트'를 가지고 있어야 함!

6-11 예제... 별 의미 없다...



------------------------

	5. 라인 크기

--------------------

	6. 캐시 수
-계층적 캐시
 ·온-칩 캐시
 ·계층적 캐시
 ·분리 캐시

계층적 캐시에서의 히트율