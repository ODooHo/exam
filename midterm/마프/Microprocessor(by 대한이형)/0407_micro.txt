 204p.
·프로시저 호출 명령
어떤 작업을 수행하고 있다가, 다른 곳으로 점프하고 점프해서 작업을 수행하다가 끝나면.. 원래 수행하고 있던 작업의 다음 작업으로 정확하게 돌아가야 한다. 이 과정을 복귀 라고 함.
 -복귀 할때는 복귀 주소를 프로시저에 전달하거나, 복귀할 수 있도록 어딘가에 주소를 잘 적어놔야 한다. 복귀 주소는: 메모리, 레지스터, 스택 세 군데에 배치 가능. 
-프로시저는 여러번 호출 가능하므로 프로시저 여러개가 직접·간접 호출 되어도 프로그램이 정상 실행 -> 프로시저 안에서 또다른 프로시저를 호출해서 작업 가능. 완료가 되면 이전 작업으로 돌아가서 마저 작업..
 -프로시저 호출 명령이 복귀 주소와 함께하는 가장 좋은 방법은 [스택!]
 처음 복귀 주소를 스택 바닥에 깔고 (1번), 두번째 호출 복귀 주소를 1번 위에 쌓는다. 복귀할때는 2번 부터 꺼내서 복귀한다 = 스택!
->프로시저가 끝나면 반환 주소를 프로그램 카운터 (다음 실행될 명령어를 저장하는 곳)에 저장
= 스택을 프로그램 카운터에게 옮겨와야한다.
 ·복귀 주소는 이전 복귀 주소가 파손되지 않도록 자동 저장

 ·루프 제어 명령
do {
 ---
 --- 
 i++;
 } while (i < 10);
: 종료 조건을 만족해야 넘어가서 다음 명령 실행
 -종점 테스트
:한 번은 반드시 실행해야됨. 
 -종료 검사를 사전에 수행하도록 루프 구성: 루프의 시작 시점에서 검사
-> 처음부터 조건 만족: 루프에 포함된 내용을 한 번도 실행하지 않음=불필요한 루프 제외 가능

  ·입출력 명령어
-굉장히 다양 (모니터, 키보드, 마우스, 펜 등)
  -프로그래밍에 의한 입출력
  ·가장 단순함. 프로그래밍 코드
->임베디드 시스템 또는 실시간 시스템 같은 저사양 마이크로프로세서에서 사용
-> 단점: 장치가 준비되기를 기다리는 긴 시간을 CPU가 낭비하게 됨 = 사용 대기 (busy waiting) 존재. 명령어가 실행될 때 까지 다른 명령어를 실행 못함. 코드에서 IO장치까지 갈 때 까지 길이가 너무 길다. CPU가 할 일이 1개 뿐이라면 문제되진 않음
  -인터럽트 구동 입출력
: 외부 신호에 의해 프로그램의 실행 흐름이 바뀜.

 -DMA(direct memory access) 입출력
  ·버스에 직접 엑세스할 수 있는 방법: 시스템에 DMA 제어기 추가: 직접 묻지 말고 중간에 센터를 하나 새워서 걔가 처리함.
 ·DMA 칩은 레지스터 최소 4개 보유
1. 읽거나 쓸 메모리 주소 포함
2. 얼마나 많은 바이트(워드)가 전송되는지 계산
3. 사용할 장치 번호 또는 입출력 공간 주소 지정
4. 입출력 장치에서 데이터를 읽거나쓰는 여부지정
 :프로세서 입출력의 부담을 크게 덜어 줌
 [사이크 스틸링]: DMA 제어기가 CPU에서 버스 사이클을 제거 = 사이클 스틸링으로 인한 이득이 인터럽트로 인한 손실 보다 큼.


	05 주소 지정 방식
|OPcode|주소 (0/1/2/3주소)|
  1. 즉시 주소 지정 = 주소값 자체가 바로 나온다
·명령어 자체에 오퍼랜드를 포함
·오퍼랜드가 포함되어 명령어가 인출될 때 오퍼랜드도 자동으로 인출
·즉시 사용 가능
|CPU <- BUS로 연결 -> Mem|
Mem에서 명령어를 1번 가져왔는데, 뒤에 있는 데이터 부분 자체가 데이터다 (= 다시 메모리로 갈 필요가 없다) =즉시 사용 가능!
 ·장점: 오퍼랜드 인출을 위한 추가적인 메모리 참조가 필요 없음
 ·단점: 상수만 가능, 값의 크기가 필드 크기로 제한
-> 작은 값의 정수를 지정하는 데 많이 사용
   2. 직접 주소 지정
·메모리에 위치한 오퍼랜드의 [전체 주소] 지정
= 포인터와 유사함. int *ptr = &i;
·직접 주소 지정도 즉시 주소 지정처럼 사용 가능

  3. 레지스터 주소 지정
 : 직접 주소 지정과 개념은 같고 그 위치가 메모리 대신 [레지스터]
 ·가장 일반적인 주소 지정 방식
:레지스터는 액세스가 빠르고 주소가 짧기 때문
: 컴파일러는 루프 인덱스처럼 가장 자주 액세스 할 변수를 레지스터에 넣기 위해 노력함. 무조건 되는건 아님!!
 ·RISC 등에서 LOAD, STORE 명령 제외하고 대부분 명령어는 레지스터 주소 지정 방식만 사용
 ·LOAD, STORE 명령어
: 한 오퍼랜드는 레지스터, 다른 한 오퍼랜드는 메모리 주소
|opcode|R12(레지스터)|R7(주소, 포인터|

 4. 레지스터 간접 주소 지정
:데이터인줄 알고 가봤더니 사실 주소지롱~????
 R12는 레지스터 주소 지정, R7은 데이터 주소..
-> 메모리로 찾아가야함
-> 이런 짓을 왜 할까? 명령어 주소가 4bit밖에 안되기 때문에 레지스터 주소를 써넣는것.
 장점: 명령어에 전체 메모리 주소가 써있지 않아도 메모리 참조 가능. 명령어 자체에는 주소가 나와있지 않음. 데이터 명령어 자체가 주소를 쓰기 위해 낭비되지 않으니 더 많은 operand를 표현 가능

* 1:06:00 레지스터 R1에 있는 요소의 합계 계산

1) MOVE R1, 0; : 레지스터 R1에 0을 지정 = 즉시 주소 지정.
2) MOVE R2, A; : A는 배열(메모리 주소): 직접 주소 지정 = 레지스터 R2에 지정
3) MOVE R3, A+400; : 배열을 벗어나는 첫 번째 주소 지정 = 직접 주소 지정
4) ADD R1, (R2); : 초기값에 (괄호를 치면 간접 주소 지정) R2에 들어있는 주소로 가서 그 값을 가져와서 그 값을 R1에 더해주고, R1에 다시 저장 
->R2는 간접 주소 지정
5) ADD R2, 4; :R2를 그 다음걸 가리키게 해야하므로 4를 더하고 R2에 저장 = 즉시 주소 지정;
6) CMP R2, R3; :배열을 벗어났는지 확인. R2와 R3를 비교해서 두개가 같나 확인 = 레지스터 주소 지정
7) BLT LOOP (Branch less than?): R2 < R3이라면 LOOP= 4) ADD R1, (R2)로 가서 반복.
