review 풀이

	4번.
인터럽트 서비스 루틴의 마지막인 RET 명령어를 인출한 후 레지스터와 스택의 상태이다. 이 명령어를 실행한 후 값이 변하는 레지스터의 값을 적어라

인터럽트 서비스 루틴: 실행의 흐름을 바꾸고, 어딘가로 점프했다가 다시 돌아오는 것.
-> 인터럽트를 실행할때는 
상태 레지스터: SR 에다가 
PUSH SR = 상태 레지스터를 스택에 넣는다.
그 다음 PUSH PC (현재 PC 값을) 스택에 옮긴다. 그 다음 PC <- ISR 

인터럽트 수행했을때:
1. PUSH SR 
2. PUSH PC 
( PC <- ISR )

RET 실행하면: 위와 연계
POP PC (PC 정보를 PC레지스터에 넣는다)
POP SR (SR=1번의 flag 정보들)

{ +우리의 스택은 PUSH: SP <- SP-[단어크기]
...}

SP = 800a
스택 800ah의 값 1234h를 PC 값이라 하자.
그 밑 8008의 8042가 SR
-> 현재 pc= 08FEh 현재 SR= 8067h
---> 인터럽트 서비스 루틴에서 마지막 명령어인 RET를 인출만하고 아직 실행은 안함.

POP PC를 실행하면: PC: 1234h SP: 8008h 
POP SR= SR: 8042, SP: 8006h


즉! 
1. 'POP PC' 를 하면 현재 SP가 가리키는 800ah의 값 1234h를 PC레지스터에 넣고 SP는 1감소 -> PC = 1234h, SP=8008h
2. 'POP SR'을 하면 SR레지스터에 SP가 가리키는 값이 들어간다. SP는 8008h 이므로 
SR = 8042h, SP는 1감소해서 8006h로 마무리

	5번

P. 32비트 명령 cpu가 128가지 연산을 수행, 내부 레지스터 수는 32개, 이는 연산 코드 필드와 레지스터 번호를 나타내는 오퍼랜드1 및 나머지 비트들로 구성되는 주소 필드 (오퍼랜드2)로 구성.

(1) 명령어 형식을 표시하라

-> 128가지의 연산.
128 = 2^7
- 7bit 가 있으면 128가지의 연산 가능.
	따라서 opcode가 7bit
- 레지스터 32개. 32 = 2^5
	레지스터 5bit 차지(오퍼랜드 1)
- 남은 메모리는 32 - 7 - 5 = 20bit
 	= 오퍼랜드2

(2) 주소는 20bit = 전체 개수는 2^20개
2^20개의 서로 다른 공간을 표시 가능.
1개의 주소가 1byte
전체 주소의 용량은 = 1byte * 2^20 
	=> 2^20 = M
-> 1 MByte.

참고 표
: 2^10 = 10^3 = K
2^20 = 10^6 = M
2 ^30 = 10^9 = G


연습문제 4번

현재: 450
명령어 길이: 16bit = 2byte. 기억 장치 (메모리): 1Byte 단위 