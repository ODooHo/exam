	494 p.

	01 인터럽트 종류
·외부, 내부, 소프트웨어

	인터럽트 우선순위
·외부 인터럽트 > 내부 인터럽트 > 소프트웨어 인터럽트


	02 인터럽트 동작 원리

1. 인터럽트 동작 과정
: 	인터럽트 시스템의 기본 요소
·인터럽트 요청 신호
·인터럽트 처리 루틴
·인터럽트 서비스 루틴

	인터럽트 처리 순서 497

·인터럽트 요청 신호 INTR
: 제어 입력 신호이며, 인터럽트를 요청하는 장치가 구동

·인터럽트 확인 신호 INTA
: 제어 출력 신호이며, CPU가 인터럽트를 요청한 장치에 인터럽트를 인식했음을 알려줌

	+ 인터럽트 서비스 루틴 = 인터럽트 핸들러

·인터럽트 사이클에서 CPU가 수행하는 작업 499
1. 인터럽트 서비스 루틴을 마치고 현재 실행 중인 프로그램으로 복귀할 때 필요한 정보를 저장한다.
2. 인터럽트를 요청한 장치를 판별한다.
3. 해당 인터럽트 서비스 루틴을 실행할 수 있도록 준비한다.



	2. 프로그램 상태의 보존  4가지
1. 인터럽트 서비스 루틴에 저장 - 501p.
(Tip: PC값 혼동하지 말기)
INT A의 ISR의 시작 301과 다음 302에
301에는 PC값, 302에는 PSWR (주 프로그램)을 박아논다.
-> 실제 서비스 루틴은 303 부터 시작함

2. 스택에 저장
301, 302 건너뛰지 않고, 301부터 잘 시작함. 스택에 쌓이기 때문에

3. 별도의 레지스터 세트에 저장
: 레지스터 세트를 여러 개 두고 인터럽트 서비스 루틴의 수행이 필요할 때마다 새로운 레지스터 세트를 할당.

4. 인터럽트 벡터
: 인터럽트 벡터 테이블을 별도로 마련


	507p.	인터럽트 처리 방법

	1. 소프트웨어를 이용한 방법 (폴링)

INTR: 인터럽트 요청

장치 0이 인터럽트를 켜서 D -> IRQ -> G1로 들어간다.
IE는 CPU가 내보내는 신호이다.
IE 와 IRQ가 모두 1이여야 G1에서 1이 출력됨. (AND 게이트)

G1에서 RI로 INTR이 들어가면 CPU가 인터럽트를 인지하고, 누가 인터럽트를 냈는지 확인한다. 
-> 폴링 회선에 장치들의 고유 번호가 들어가있다.
-> 장치 번호 디코더로 신호를 내보냄. 6번 G2 (AND게이트)
-> 나머지 연결이 IRQ다. 장치 0이 인터럽트를 켰으니, G2 출력이 1이 나옴. 그러면 7번을 통해 reset이 되므로, 최종적으로 CPU가 인터럽트 발생 여부를 알고, 누가 보냈는지도 알게됨.

·인터럽트 처리 과정 (스택을 사용하는 경우)
1. 인터럽트 요청
2. PC 와 RSWR 저장하구
3. 장치 판별 루틴 
4. 장치 찾음


	2. 하드웨어 이용한 방벙 (데이지 체인)
INTA: 인터럽트 확인선 존재

->RI로 값이 들어오면 INTA에서 1을 내보냄. G2와 G4로.

->G2로 요청 하면. G2 출력으로 1이 나옴. 그럼 장치 번호 발생기 G3로 간다. 

->G3는 장치 번호 버스로 간다. (장치 번호 버스에 점 찍혀 있으면 1이다). ******* 예시에는 장치번호: 0 1 0 1

 -> 장치 0이 범인이 아니면, " 자동으로 다음 녀석을 검사하게 만들어주는 기법:"  "데이지 체인"

-> INTA 신호가 G2, G4로 들어갔는데 G4의 나머지 입력 하나가 NOT게이트이다. 이거는 IRQ와 연결되어 있는데 장치 0의  IRQ가 0이라면 (장치0이 아니다) G4에 1, 1이 들어가서 장치 1로 이어져서 검사한다.

	인터럽트 우선순위
: 선에 연결에 따라 처음 연결된 것 부터 처리한다.
자연스럽게 장치 0번이 우선순위가 가장 높다.



	3. 다중 인터럽트 요청선을 이용한 방법
: IRQ가 장치 개수 만큼 있어야함.
-> CPU에서 복잡도가 증가함.
-> 데이지 체인 필요없음. 왜? 장치 몇번인지 바로 알 수 있기 때문에.
	인터럽트 우선순위

---------40분 부터 다시------------

