캐시는 용량이 작다!

	2. 사상 방식 Mapping
319p.
·블록: 워드를 여러개로 합쳐논 것
1블록은: k개의 워드가 있다
 왜? 캐시를 보면 1개의 라인의 1개의 블록이 있음

·태그: 주기억 장치의 주소를 쪼개서 일부는 태그, 일부는 블록, 일부는 라인이됨

	
		
주기억 장치의 용량은 2^7 = 128 바이트

주기억 장치 주소 = 7비트
-> MAR 주소 선이 7개.. 128개 * 1word/1byte

블록은 = 4바이트 => 즉, 워드 4개
-> 캐시 1개 라인에 워드 4개가 들어감
-> 주기억 장치에 128/4 = 32개의 블록이 있다.

캐시 = 32바이트, 캐시 라인의 크기 = 4바이트 (블록 크기와 동일)

전체 캐시 라인의 수, m = 32/4 = 8개

주기억 장치 7bit, 캐시 5bit
-> 7비트를 5비트로 바꾸는 것이 매핑!

 캐시가 가득 차 있을때, 주기억 장치에 하나를 캐시에 넣어야한다면, 캐시에서 하나를 빼야한다. 어떤것을 빼면 좋을까?
+ (공간적 지역성, 시간적 지역성 재등장)

·직접 사상
 : 주기억 장치의 블록들이 지정된 '하나의 라인으로만' 적재됨
-> 0번 블록은 0번 라인. 0번 라인을 1번 라인에 넣고 싶어도 안됨. 0번 라인에 딴게 있어도 밀어내고 0번 라인에 들어감

주기억 장치 주소는 태그, 라인, 워드 필드로 구성
		2 + 3 + 2 = 7!

·워드:  2bit (한 블록내에 워드 4개가 들어감)
·태그:  2bit : 몇번째 라인인지 파악
·라인: 캐시 라인 수가 8개 이므로 3bit
 
주기억 장치의 블록 j가 적재될 수 있는 캐시 라인 번호는 '모듈로 연산 (=나머지 연산)'
=> ' i = j mod m ' { j = 블록 }
ex) 2 mod 8 = 2, 4 mod 8 = 4 ... 안나눠지니까!
8 mod 8 = 0, 9 mod 8 = 1..

14p.
 5비트중 하위 3비트는 계속 반복됨.. 000, 001..
-> 라인 번호
상위 2비트 = 태그
태그는 00, 01, 10, 11로 다르다.
태그가 같으면, 다른 라인을 쓰는 애들..
이웃한 애들은 다른 라인을 쓴다....

  예시)
주기억 장치 주소 11 101 01가 캐시로 가는 과정
태그: 11, 라인 101, 워드 01
1. 11 101 만 본다.
2. 라인 번호 101이므로 5번 캐시 라인 ㄱㄱ
3. 캐시에 잇는 5번 라인을 가보니 태그가 11이다
-> 찾아야하는 태그도 11이고, 5번 라인에 들어있는 것도 11이다. 이건 "히트" 했다는 얘기다.
4.워드가 01이므로 poet중 o가 인출되어 cpu로 전송
<-> 만약 히트가 안됐을 경우, 주기억 장치로 가서. 값 하나만 가져오는 것이 아니라, 해당 블록을 가져와서 위치에 있는 값과 바꿔치기치기한다.

예제 6-6 
 -할만함

  완전- 연관 사상
태그: 5비트, 워드 : 2비트
-> 주소가 주어지면 상위 5비트를 보고, 캐시 5비트와 다 비교함 ㅋㅋ
 : 캐시의 라인번호와 태그 필드는 관련이 업ㄷ따!
???여기서 캐시가 꽉찼는데 또 데이터를 읽으라고 한다면 어떻게 될까????/

  세트-연관 사상
캐시 라인 m은 v개의 세트들로 나뉘며, 각 세트들은 k개의 라인들로 구성 (k-way)
m = v * k
i = j mod v

 + 세트번호는 j mod 4로 결정
같은 세트에 뭘 할당해도 그냥 비어있는 곳에 넣으면 된다.
2-way 세트- 연관 사상 방식 (2개가 이어짐)

동작 예시:
세트 필드 -> 태그 필드 -> 워드 필드 확인

(5비트를 한번에 비교하는 것보다, 2비트 -> 3비트 확인하는 것이 훨씬 효율적)


