12p. 
	Booth Algorithm

M: m4m3m2m1
Q: q4q3q2q1	q0에 0을 대입
A (연산의 결과) 레지스터 0으로 초기화.
: a4a3a2a1
n: number of bits

q1과q0를 나란히 놓고, 그 값이 뭔지에 따라 어디로 갈지 정해짐.  00 or 01 or 10 or 11
00이나 11일때는 아무것도 안하고 밑으로 내려옴 ->Arithmetic shift right AQq0 (오른쪽 산술시프트) : AQq0를 하나의 비트로 묶은 다음 오른쪽으로 비트를 옮겨라. 
-> 맨 왼쪽에 생길 빈칸에는 산술시프트이므로 부호를 유지해서 채움.   
AQq0: a4a3a2a1q4q3q2q1q0 
-> a4가 1이면 빈칸은 1로 채운다.
-> n=n-1에서 n=3이 됨 다시 q1q0로 올라감.

13p.

M: -7 	A: 0	q0: 0	n = 4
Q: 3

15p.

ASL = LSL 은 같다. 0으로 채운다.
ASR: 부호 비트 유지, LSR 부호 상관 없이 0으로 채운다.
ROL: 왼쪽으로 1비트 회전 시프트. MSB가 LSB로 시프트됨.
ROR: ROL의 반대
ROLC (rotation left with carry): A[7]이 C로 가고 C는 A[0]로 간다.
RORC: C가 A[7]로 가고 A[0]가 C로 간다.

+ ASL: 2를 n번 곱한 효과
+ ASR: 2를 n번 나눈 효과


----------------------------------

CPU안에 있는 저장공간 : [레지스터]!!! (가장 빠른 메모리)
+ 매우 단순한 마이크로프로세서는 누산기(AC) 레지스터 1개로만 구성 가능

 ·레지스터 용도에 따른 종류
-누산기 (AC)
-프로그램 카운터(PC)
-명령 레지스터(Instruction Register, IR)
-인덱스 레지스터(Index Register, IX)
-스택 레즈시터(SP)
-메모리 데이터 레즈시터(MDR, MBufferR)
-메모리 주소 레지스터(MAR)


LOAD: 메모리에서 레지스터로 가져오는 것
STORE: 레지스터에서 메모리로 저장하는 것
MOVE: 레지스터에서 레지스터로 데이터를 이동
: 인텔 프로세스는 이 세가지를 MOVE 명령으로 모두 처리

 ·데이터 교환
-MOVE 명령을 세번 사용하여 두 오퍼랜드를 교한 (C언어 temp 생각)