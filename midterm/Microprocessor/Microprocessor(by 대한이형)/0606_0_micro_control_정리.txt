	Control_1

마이크로 명령 설계 순서 - 11p.
마이크로 프로그램 제어 장치의 종류
 -수평적 마이크로 프로그램
 -수직적 마이크로 프로그램

17p.	명령어 사이클 

·명령어 인출 -> 명령어 해독 -> 명령어 실행
·인터럽트 사이클은 매 명령어 사이클이 끝나고 인터럽트 유무를 점검



 ++++++++ (SP)와 SP는 다름. ()가 있으면 들어있는 값임
	명령어 인출 사이클	254p.
t1: MAR <- PC
t2: MBR <- M[MAR], PC <- (PC)+ I
t3: IR <- MBR

· I : 명령어의 크기
·바이트 단위 주소 지정이고, 명령어의 기본 크기가 2바이트라면 I는 2가 됨

	명령어 해독 사이클
t1: Decoder <- (IR:opcode) opcode는 1이라 가정
t2: Instruction Decoding   = CU가 제어신호 발생
ex) IR에 저장된 1860중 1은 opcode. 860은 오퍼랜드
·opcode = 1은 LOAD 
-> R1에 값을 읽어 오는 것 (R1: 누산기 역할이라 가정)

	명령어 실행 사이클
t1: MAR <- (IR:operand)
t2: MBR <- M[MAR]
t3: R1 <- (MBR)

	ADD R1, X
t1: MAR <- (IR:X)
t2: MBR <- M[MAR]
t3: R1 <- (R1)+MBR

	1: LOAD, 	5: ADD, 	2: STORE
* STORE시 PC <- PC + I


	ISZ increment /and Skip if Zero (0이면 skip)
: X 값을 1 증가시키고 그 결과가 0이면 다음 명령을 건너뜀

t1: MAR <- (IR:X)
t2: MBR <- M[MAR] + 1
t3: M[MAR] <- (MBR), If ((MBR)==0) then (PC <- PC+I)

	*** BSA Branch-and-Save-Address
Branch: 분기하다.
-> 인터럽트에서 돌아올 주소를 저장하는 것.

	BSA X:
t1: MAR <- (SP), MBR <- (PC) 		+ SP:스택
t2: M[MAR] <- (MBR), SP <- SP - I
t3: PC <- (IR:X)

258p.
9550 -> 	9:BSA,	 X:550


++ 560번지에서 복귀 명령 (9000)이 있다고 가정

	RET (return)
t1: SP <- SP + I
t2: MAR <- (SP)
t3: MBR <- M[MAR]
t4: PC <- MBR


 ****** 무적권 나올듯!	
260p. 다중 서브루틴이 호출되는 상황에서 레지스터 변화 



	4. 인터럽트 사이클
t1: MAR <- (SP), MBR <- (PC)
t2: M[MAR] <- (MBR), SP <- SP -I
t3: PC <- Interrupt_Service-Routine_Address

	5. 명령어 사이클




------------------------------


	04 프로세스 제어
- 프로세스 제어의 3가지
·데이터 경로
·ALU
·시스템 버스

265p. 는 마이크로 연산에 따른 제어 신호 동작
·CR: 읽는 것 ·CW: 쓰는 것

----------------------------

	05 파이프 라이닝
처리속도
-MIPS Million instructions per second
: 초당 실행되는 명령 개수를 100만으로 나눔

예시:
 각 단계가 2ns 소요된다면
-전통적인 시스템에선 명령 하나가 완전히 실행되는 데는 "10ns" 소요
-파이프라인 시스템에서는 매 클록 사이클 (2ns) 마다 명령 5개가 동시에 실행되므로, 시간은 1/5로 단축
-> 전통적인 시스템 100MIPS
->5개 파이프라인 가진 컴퓨터 500MIPS

정리
 -한 사이클에 소요되는 시간: T ns
 -파이프 라인: n 단계
 -전체 실행 시간: nT ns(nano sec)
(위의 예시. 2ns, 5단계 = 10ns)
-> 클록 사이클이 초당 10^9/T 라면 초당 실행되는 명령의 개수는 10^9/T개.. 
-> 예를 들어 T=2ns인 경우 매초 5억건의 명령이 실행
 = 10억 / 2 이므로.
-> MIPS는 (10^9/T) / 10^6


-> GIPS 로 바꾸라는 문제 나올듯.

	1. 데이터 해저드 (hazards = 위험)
예시: 첫 번째 연산 ADD의 결과 r3가 두 번째 연산 SUB의 입력으로 사용

------------------------------------- 

	파이프라이닝

https://hotstudy.tistory.com/98

2-8번 풀이에 오류가 있는거같습니다. 파이프라인을 이용하지 않은 경우에, 프로그램 처리시간은 각각의 단계가 클록이라 했을때, 100개는 2클록씩, 400개는 3클록씩, 500개는 4클록씩 필요합니다. 따라서 200+1200+2000= 3400 ns가 맞지않나요?
또 2-8에 2번 문제도, 4단계 파이프라인으로 푼다고 했으므로 단순히 T=k+n-1 을 사용하여 4+999 =1003 이 맞다고 생각합니다. 피드백 부탁드려요 !



	명령어 인출 계산
https://www.happycampus.com/report-doc/20055391/

4단계라면 에 명령어 100개에 클록 주기 2ns 면

4 + (100-1) = 103 주기
103 * 2 = 206 ns

